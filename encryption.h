#pragma once
#include <opencv2/opencv.hpp>

using namespace cv;
using namespace std;

const int MAX = 1e4 + 79;

/**
  u is the control parameter for logistic chaotic map,also known as population rate
  Here u is taken 3.94
  x is the vector that contain the value generated by chaotic map
  The initial value of the logistic chaotic map is 0.4
*/

Mat stepByStep(Mat detected, int bboxX, int bboxY, int bboxWidth, int bboxHeight) {
    auto start = getTickCount();
    int i, l;
    double u = 3.94;
    vector<pair<double, int >> x;
    Vec<unsigned char, 3>  pixel;

    x.push_back({ 0.4,0 });


    double temp;
    for (int i = 1; i <= 511; ++i) {
        temp = u * x[i - 1].first * (1 - x[i - 1].first);
        x.push_back({ temp,i });
    }

    sort(x.begin(), x.end());

    imshow("Original image", detected);
    waitKey(0);

    i = 0;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 511)
                i = 0;
            int temps = x[i].second;

            pixel = detected.at<Vec3b>(r, temps);
            detected.at<Vec3b>(r, temps) = detected.at<Vec3b>(r, c);
            detected.at<Vec3b>(r, c) = pixel;

            i++;
        }
    }

    imshow("permutated image", detected);
    waitKey(0);

    auto end = getTickCount();
    auto totalTime = (end - start) / getTickFrequency();
    cout << "w:" << bboxWidth << " h:" << bboxHeight << " t:";
    cout << totalTime;
    auto start2 = getTickCount();

    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            detected.at<Vec3b>(r, c)[0] = detected.at<Vec3b>(r, c)[0] ^ l;
            detected.at<Vec3b>(r, c)[1] = detected.at<Vec3b>(r, c)[1] ^ l;
            detected.at<Vec3b>(r, c)[2] = detected.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }
    auto end2 = getTickCount();
    auto totalTime2 = (end2 - start2) / getTickFrequency();
    cout << " t2:" << totalTime2 << endl;

    return detected;
}

static void NPCR_UACI(cv::Mat img1, cv::Mat img2, int m, int n, int ch)
{
    double NPCR = 0, UACI = 0, init = 0, sum = 0, sum_uaci = 0;

    for (int i = 0; i < img1.rows; ++i)
    {
        for (int j = 0; j < img1.cols; ++j)
        {
            for (int k = 0; k < img1.channels(); ++k)
            {

                init = (double)img1.at<Vec3b>(i, j)[k] - img2.at<Vec3b>(i, j)[k];
                sum_uaci += fabs(init);
                if (img1.at<Vec3b>(i, j)[k] != img2.at<Vec3b>(i, j)[k])
                {
                    NPCR = 1;
                    sum += NPCR;
                }
            }
        }
    }

    sum = (sum * 100) / (m * n * ch);
    printf("\nNPCR = %F", sum);
    sum_uaci = sum_uaci / (m * n * 255 * ch);
    printf("\nUACI = %F", sum_uaci * 100);
}

Mat hist(Mat src) {
    vector<Mat> bgr_planes;
    split(src, bgr_planes);
    int histSize = 256;
    float range[] = { 0, 256 }; //the upper boundary is exclusive
    const float* histRange[] = { range };
    bool uniform = true, accumulate = false;
    Mat b_hist, g_hist, r_hist;
    calcHist(&bgr_planes[0], 1, 0, Mat(), b_hist, 1, &histSize, histRange, uniform, accumulate);
    calcHist(&bgr_planes[1], 1, 0, Mat(), g_hist, 1, &histSize, histRange, uniform, accumulate);
    calcHist(&bgr_planes[2], 1, 0, Mat(), r_hist, 1, &histSize, histRange, uniform, accumulate);
    int hist_w = 512, hist_h = 400;
    int bin_w = cvRound((double)hist_w / histSize);
    Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));
    normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
    normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
    normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
    for (int i = 1; i < histSize; i++)
    {
        line(histImage, Point(bin_w * (i - 1), hist_h - cvRound(b_hist.at<float>(i - 1))),
            Point(bin_w * (i), hist_h - cvRound(b_hist.at<float>(i))),
            Scalar(255, 0, 0), 2, 8, 0);
        line(histImage, Point(bin_w * (i - 1), hist_h - cvRound(g_hist.at<float>(i - 1))),
            Point(bin_w * (i), hist_h - cvRound(g_hist.at<float>(i))),
            Scalar(0, 255, 0), 2, 8, 0);
        line(histImage, Point(bin_w * (i - 1), hist_h - cvRound(r_hist.at<float>(i - 1))),
            Point(bin_w * (i), hist_h - cvRound(r_hist.at<float>(i))),
            Scalar(0, 0, 255), 2, 8, 0);
    }
    imshow("Source image", src);
    imshow("calcHist Demo", histImage);
    waitKey();
    return histImage;
}

Mat encrypt(Mat detected, int bboxX, int bboxY, int bboxWidth, int bboxHeight) {
    auto start = getTickCount();
    int i, l;
    double u = 3.94;
    vector<pair<double, int >> x;
    Vec<unsigned char, 3>  pixel;

    x.push_back({ 0.4,0 });


    double temp;
    for (int i = 1; i <= 511; ++i) {
        temp = u * x[i - 1].first * (1 - x[i - 1].first);
        x.push_back({ temp,i });
    }

    sort(x.begin(), x.end());

    /*imshow("Original image", detected);
    waitKey(0);*/

    i = 0;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 511)
                i = 0;
            int temps = x[i].second;

            pixel = detected.at<Vec3b>(r, temps);
            detected.at<Vec3b>(r, temps) = detected.at<Vec3b>(r, c);
            detected.at<Vec3b>(r, c) = pixel;

            i++;
        }
    }

    /*imshow("permutated image", detected);
    waitKey(0);*/

    auto end = getTickCount();
    auto totalTime = (end - start) / getTickFrequency();
    cout << "w:" << bboxWidth << " h:" << bboxHeight << " t:";
    cout << totalTime;
    auto start2 = getTickCount();

    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            detected.at<Vec3b>(r, c)[0] = detected.at<Vec3b>(r, c)[0] ^ l;
            detected.at<Vec3b>(r, c)[1] = detected.at<Vec3b>(r, c)[1] ^ l;
            detected.at<Vec3b>(r, c)[2] = detected.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }
    auto end2 = getTickCount();
    auto totalTime2 = (end2 - start2) / getTickFrequency();
    cout << " t2:" << totalTime2 << endl;
    /*
    imwrite("Image/encrypted_image.jpg", detected);
    imshow("Encrypted image", detected);
    waitKey(0);





    i = 1;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            detected.at<Vec3b>(r, c)[0] = detected.at<Vec3b>(r, c)[0] ^ l;
            detected.at<Vec3b>(r, c)[1] = detected.at<Vec3b>(r, c)[1] ^ l;
            detected.at<Vec3b>(r, c)[2] = detected.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }

    imshow("Decrepted Diffused image", detected);
    waitKey(0);

    i = 511;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i < 0)
                i = 511;
            int temps = x[i].second;

            pixel = detected.at<Vec3b>(r, temps);
            detected.at<Vec3b>(r, temps) = detected.at<Vec3b>(r, c);
            detected.at<Vec3b>(r, c) = pixel;

            i--;
        }
    }

    namedWindow("Decrepted", WINDOW_AUTOSIZE);
    imshow("Decrepted", detected);
    waitKey(0);*/

    return detected;
}

Mat encrypt2(Mat detected, int bboxX, int bboxY, int bboxWidth, int bboxHeight) {
   auto start = getTickCount();
    int i, l;
    double u = 3.94;
    vector<pair<double, int >> x;
    Vec<unsigned char, 3>  pixel;

    x.push_back({ 0.4,0 });


    double temp;
    for (int i = 1; i <= 511; ++i) {
        temp = u * x[i - 1].first * (1 - x[i - 1].first);
        x.push_back({ temp,i });
    }

    sort(x.begin(), x.end());

    /*imshow("Original image", detected);
    waitKey(0);*/

    i = 0;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 511)
                i = 0;
            int temps = x[i].second;

            pixel = detected.at<Vec3b>(r, temps);
            detected.at<Vec3b>(r, temps) = detected.at<Vec3b>(r, c);
            detected.at<Vec3b>(r, c) = pixel;

            i++;
        }
    }

    /*imshow("permutated image", detected);
    waitKey(0);*/

    auto end = getTickCount();
    auto totalTime = (end - start) / getTickFrequency();
    cout << "w:" << bboxWidth << " h:" << bboxHeight << " t:";
    cout << totalTime;
    auto start2 = getTickCount();

    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            detected.at<Vec3b>(r, c)[0] = detected.at<Vec3b>(r, c)[0] ^ l;
            detected.at<Vec3b>(r, c)[1] = detected.at<Vec3b>(r, c)[1] ^ l;
            detected.at<Vec3b>(r, c)[2] = detected.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }
    auto end2 = getTickCount();
    auto totalTime2 = (end2 - start2) / getTickFrequency();
    cout << " t:" << totalTime2;


    //imwrite("Image/encrypted_image.jpg", detected);
    //imshow("Encrypted image", detected);
    //waitKey(0);


    
    auto start3 = getTickCount();
    /*
    i = 1;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            detected.at<Vec3b>(r, c)[0] = detected.at<Vec3b>(r, c)[0] ^ l;
            detected.at<Vec3b>(r, c)[1] = detected.at<Vec3b>(r, c)[1] ^ l;
            detected.at<Vec3b>(r, c)[2] = detected.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }

    //imshow("Decrepted Diffused image", detected);
    //waitKey(0);

    i = 511;
    for (int r = bboxX; r < bboxX + bboxWidth; ++r) {
        for (int c = bboxY; c < bboxY + bboxHeight; ++c) {
            if (i < 0)
                i = 511;
            int temps = x[i].second;

            pixel = detected.at<Vec3b>(r, temps);
            detected.at<Vec3b>(r, temps) = detected.at<Vec3b>(r, c);
            detected.at<Vec3b>(r, c) = pixel;

            i--;
        }
    }

    //namedWindow("Decrepted", WINDOW_AUTOSIZE);
    //imshow("Decrepted", detected);
    //waitKey(0);
    */
    auto end3 = getTickCount();
    auto totalTime3 = (end3 - start3) / getTickFrequency();
    cout << " t:" << totalTime3 << endl;
   
    return detected;

}
Mat encrypt3(Mat image) {
    auto start = getTickCount();
    int i, l;
    double u = 3.94;
    vector<pair<double, int >> x;
    Vec<unsigned char, 3>  pixel;

    x.push_back({ 0.4,0 });


    double temp;
    for (int i = 1; i <= 511; ++i) {
        temp = u * x[i - 1].first * (1 - x[i - 1].first);
        x.push_back({ temp,i });
    }

    sort(x.begin(), x.end());

    /*imshow("Original image", image);
    waitKey(0);*/

    i = 0;
    for (int r = 0; r < image.rows; ++r) {
        for (int c = 0; c < image.cols; ++c) {
            if (i > 511)
                i = 0;
            int temps = x[i].second;

            pixel = image.at<Vec3b>(r, temps);
            image.at<Vec3b>(r, temps) = image.at<Vec3b>(r, c);
            image.at<Vec3b>(r, c) = pixel;

            i++;
        }
    }

    /*imshow("permutated image", image);
    waitKey(0);*/

    auto end = getTickCount();
    auto totalTime = (end - start) / getTickFrequency();
    cout << "w:" << image.rows << " h:" << image.cols << " t:";
    cout << totalTime;
    auto start2 = getTickCount();

    for (int r = 0; r < image.rows; ++r) {
        for (int c = 0; c < image.cols; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            image.at<Vec3b>(r, c)[0] = image.at<Vec3b>(r, c)[0] ^ l;
            image.at<Vec3b>(r, c)[1] = image.at<Vec3b>(r, c)[1] ^ l;
            image.at<Vec3b>(r, c)[2] = image.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }
    auto end2 = getTickCount();
    auto totalTime2 = (end2 - start2) / getTickFrequency();
    cout << " t:" << totalTime2;
    /*imwrite("Image/encrypted_image.jpg", image);
    imshow("Encrypted image", image);
    waitKey(0);*/
    /*
    auto start3 = getTickCount();

    i = 1;
    for (int r = 0; r < image.rows; ++r) {
        for (int c = 0; c < image.cols; ++c) {
            if (i > 100) {
                i = 1;
            }
            l = x[i].first * MAX;
            l = l % 255;
            image.at<Vec3b>(r, c)[0] = image.at<Vec3b>(r, c)[0] ^ l;
            image.at<Vec3b>(r, c)[1] = image.at<Vec3b>(r, c)[1] ^ l;
            image.at<Vec3b>(r, c)[2] = image.at<Vec3b>(r, c)[2] ^ l;
            i++;
        }
    }

   /* imshow("Decrepted Diffused image", image);
    waitKey(0);*/
    /*
    i = 511;
    for (int r = image.rows - 1; r >= 0; --r) {
        for (int c = image.cols - 1; c >= 0; --c) {
            if (i < 0)
                i = 511;
            int temps = x[i].second;

            pixel = image.at<Vec3b>(r, temps);
            image.at<Vec3b>(r, temps) = image.at<Vec3b>(r, c);
            image.at<Vec3b>(r, c) = pixel;

            i--;
        }
    }

    //namedWindow("Decrepted", WINDOW_AUTOSIZE);
    //imshow("Decrepted", image);
    //waitKey(0);

    auto end3 = getTickCount();
    auto totalTime3 = (end3 - start3) / getTickFrequency();
    cout << " t:" << totalTime3 << endl;
    */
    return image;
}


